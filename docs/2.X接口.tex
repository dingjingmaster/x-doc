\chapter{Xlib——X的C语言接口}


\section{xlib简介}

X的前10个版本的设计和实现主要是由三个人完成的:麻省理工学院计算机科学实验室的罗伯特·舍弗勒、数字设备公司的吉姆·盖提斯和麻省理工学院的罗恩·纽曼，他们都是麻省理工学院雅典娜项目的成员。然而，X的第11个版本则是许多地方和组织共同努力的成果。

X窗口系统是麻省理工学院设计的一个网络透明窗口系统。X显示服务器运行在具有单色或彩色位图显示硬件的计算机上。服务器将用户输入分发给位于同一台机器上或网络中其他地方的各种客户机程序，并接受它们的输出请求。Xlib是一个C子例程库，应用程序(客户端)使用它通过流连接与窗口系统进行交互。尽管客户机通常运行在与其通信的X服务器所在的同一台机器上，但情况并非如此。

Xlib−C语言X接口是X窗口系统协议的低级C语言接口的参考指南。它既不是教程，也不是X窗口系统编程的用户指南。相反，它提供了库中每个函数的详细描述以及相关背景信息的讨论。Xlib−C语言X界面假定对图形窗口系统和C编程语言有基本的了解。其他高级抽象(例如，由X工具包提供的抽象)构建在Xlib库之上。有关这些高级库的进一步信息，请参阅相应的工具包文档。X窗口系统协议(Window System Protocol)\footnote{\url{https://www.x.org/releases/current/doc/}}提供了关于X的行为的权威词汇。尽管这里出现了额外的信息，但协议文档是主导文档。

\subsection{X窗口系统概述}

本书中使用的一些术语是X所独有的，而其他窗口系统通用的其他术语在X中具有不同的含义。您可能会发现参考位于本书末尾的术语表会有所帮助。

X窗口系统支持一个或多个包含重叠窗口或子窗口的屏幕。屏幕是一个物理显示器和硬件，可以是彩色、灰度或单色的。每个显示器或工作站可以有多个屏幕。单个X服务器可以为任意数量的屏幕提供显示服务。单个用户使用一个键盘和一个指针(通常是鼠标)的一组屏幕称为显示器。

X服务器中的所有窗口都按照严格的层次结构进行安排。在每个层次结构的顶部是一个根窗口，它覆盖了每个显示屏幕。每个根窗口部分或全部被子窗口覆盖。除根窗口外，所有窗口都有父窗口。通常每个应用程序至少有一个窗口。子窗口可能会有自己的子窗口。通过这种方式，应用程序可以在每个屏幕上创建任意深度的树。X为窗口提供图形、文本和光栅操作。

子窗口可以比父窗口大。也就是说，子窗口的部分或全部可以扩展到父窗口的边界之外，但是窗口的所有输出都被其父窗口剪切。如果一个窗口的几个子窗口有重叠的位置，则认为其中一个子窗口位于其他子窗口之上或高于其他子窗口，从而使它们变得模糊。输出到其他窗口覆盖的区域将被窗口系统抑制，除非该窗口具有后备存储。如果一个窗口被第二个窗口遮挡，第二个窗口只遮挡第二个窗口的祖先，同时也是第一个窗口的祖先。

窗口的边框宽度为0或更多像素，可以是任何图案(像素图)或您喜欢的纯色。一个窗口通常(但不总是)有一个背景图案，当被揭开时，它将被窗口系统重新绘制。子窗口掩盖了父窗口，父窗口中的图形操作通常由子窗口剪切。

每个窗口和像素图都有自己的坐标系统。坐标系的X轴为水平轴，Y轴为垂直轴，原点[0,0]位于左上角。坐标是积分的，以像素为单位，并与像素中心重合。对于窗口，原点在内部左上角的边界内。

X不保证保留窗口的内容。当一个窗口的部分或全部被隐藏，然后再回到屏幕上，它的内容可能会丢失。然后，服务器向客户端程序发送一个Expose事件，通知它需要重新绘制部分或全部窗口。程序必须准备好在需要时重新生成窗口的内容。

X还提供图形对象的屏幕外存储，称为pixmaps。单平面(深度为1)像素图有时被称为位图。像素图可以在大多数图形函数中与窗口互换使用，并在各种图形操作中用于定义模式或块。窗口和像素图一起被称为可绘制图。

Xlib中的大多数函数只是将请求添加到输出缓冲区。这些请求稍后在X服务器上异步执行。返回存储在服务器中的信息值的函数在接收到显式回复或发生错误之前不会返回(也就是说，它们会阻塞)。您可以提供一个错误处理程序，它将在报告错误时被调用。

如果客户端不希望请求异步执行，它可以在请求之后调用XSync，该调用将阻塞，直到所有先前缓冲的异步事件都被发送并执行。作为一个重要的副作用，Xlib中的输出缓冲区总是在调用任何从服务器返回值或等待输入的函数时被刷新。

许多Xlib函数将返回一个整数资源ID，它允许您引用存储在X服务器上的对象。这些类型可以是Window、Font、Pixmap、Colormap、Cursor和GContext，如文件<X11/X.h>中定义的。这些资源由请求创建，并在请求或连接关闭时销毁(或释放)。这些资源中的大多数都可能在应用程序之间共享，事实上，窗口是由窗口管理器程序显式地操纵的。字体和游标在多个屏幕之间自动共享。字体根据需要加载和卸载，并由多个客户端共享。字体通常缓存在服务器中。Xlib不支持在应用程序之间共享图形上下文。

客户端程序被告知事件。事件可能是请求的副作用(例如，重新堆叠窗口生成Expose事件)，也可能是完全异步的(例如，来自键盘)。客户端程序要求获得事件通知。由于其他应用程序可以向您的应用程序发送事件，因此程序必须准备好处理(或忽略)所有类型的事件。

输入事件(例如，按下键或指针移动)从服务器异步到达，并排队，直到显式调用(例如，XNextEvent或XWindowEvent)请求它们。此外，一些库函数(例如XRaiseWindow)会生成Expose和ConfigureRequest事件。这些事件也是异步到达的，但是客户机可能希望在调用一个函数之后通过调用XSync显式地等待它们，该函数会导致服务器生成事件。

\subsection{错误}

一些函数返回Status（一个表示错误信息的整数）。如果函数失败，则返回0。如果函数返回状态为0，则表示它没有更新返回参数。由于C语言不提供多个返回值，因此许多函数必须通过写入客户端传递的存储来返回结果。默认情况下，错误由标准库函数或您提供的函数处理。如果字符串不存在，返回指向字符串指针的函数返回NULL指针。

X服务器在检测到协议错误时候就会报告错误信息。如果一个给定的请求可以生成多个错误，服务器可以报告其中的任何一个。

由于Xlib通常不会立即将请求传输到服务器(也就是说，它会缓冲请求)，因此报告错误的时间可能比实际发生的时间晚得多。然而，出于调试目的，Xlib提供了一种强制同步行为的机制(参见11.8.1节)。当启用同步时，错误会在生成时报告。

当Xlib检测到错误时，它调用程序可以提供的错误处理程序。如果不提供错误处理程序，则打印错误并终止程序。

\subsection{标准头文件}

\begin{itemize}
	\item <X11/Xlib.h>：这是Xlib的主要头文件。大多数Xlib符号都是通过包含这个文件来声明的。该文件还包含预处理器符号XlibSpecificationRelease。此符号在本标准中定义为6。(Xlib的第5版是第一个有这个符号的版本。)
	\item <X11/X.h>：该文件声明了应用程序将使用的X协议的类型和常量。它从<X11/Xlib.h>自动包含，因此应用程序代码不需要直接引用该文件。
	\item <X11/Xcms.h>：这个文件包含了第6章中描述的许多颜色管理工具的符号。所有以“Xcms”为前缀的函数、类型和符号，以及颜色转换上下文宏，都在这个文件中声明。在包含此文件之前必须包含<X11/Xlib.h>。
	\item <X11/Xutil.h>：该文件声明了用于客户端间通信和应用程序实用程序的各种函数、类型和符号，这些将在第14章和第16章中描述。在包含此文件之前必须包含<X11/Xlib.h>。
	\item <X11/Xresource.h>：该文件声明了资源管理器设施的所有函数、类型和符号，这些将在第15章中描述。在包含此文件之前必须包含<X11/Xlib.h>。
	\item <X11/Xatom.h>：该文件声明了所有预定义的原子，这些原子是前缀为“XA\_”的符号。
	\item <X11/cursorfont.h>：该文件声明了标准游标字体的游标符号，它们列在附录b中。所有的游标符号都有前缀“XC\_”。
	\item <X11/keysymdef.h>：该文件声明了所有标准KeySym值，这些值是前缀为“XK\_”的符号。键盘系统按组排列，预处理器符号控制每组的包含。必须在包含文件之前定义预处理器符号以获得相关值。预处理器符号是xk\_miscellaneous, XK\_XKB\_KEYS, XK\_3270, XK\_LATIN1, XK\_LATIN2, XK\_LATIN3, XK\_LATIN4, XK\_KATAKANA, XK\_ARABIC, XK\_CYRILLIC, XK\_GREEK, XK\_TECHNICAL, XK\_SPECIAL, XK\_PUBLISHING, XK\_APL, XK\_HEBREW, XK\_THAI和XK\_KOREAN。
	\item <X11/keysym.h>：这个文件定义了预处理器符号xk\_miscellaneous, XK\_XKB\_KEYS, XK\_LATIN1, XK\_LATIN2, XK\_LATIN3, XK\_LATIN4和XK\_GREEK，然后包括<X11/keysymdefh>。
	\item <X11/Xlibint.h>：该文件声明了用于扩展的所有函数、类型和符号，这些在附录c中有描述。该文件自动包含<X11/Xlib.h>。
	\item <X11/Xproto.h>：该文件声明了基本X协议的类型和符号，以便在实现扩展时使用。它从<X11/xlibin.h>自动包含，因此应用程序和扩展代码不需要直接引用该文件。
	\item <X11/Xprotostr.h>：该文件声明了基本X协议的类型和符号，以便在实现扩展时使用。它从<X11/xproto1.h>自动包含，因此应用程序和扩展代码不需要直接引用该文件。
	\item <X11/X10.h>：该文件声明了用于X10兼容性函数的所有函数、类型和符号，这些在附录D中有描述。
\end{itemize}

\subsection{常用值和类型}

\noindent 以下符号由Xlib定义，并在整个手册中使用:
\begin{itemize}
	\item Xlib定义Bool类型和布尔值True和False。
	\item None是通用的空资源ID或原子。
	\item 类型XID用于通用资源id。
	\item 类型XPointer定义为char*，并用作指向数据的泛型不透明指针。
\end{itemize}

\subsection{Xlib中的命名和参数约定}

Xlib在函数的命名和语法方面遵循许多约定。假设您记住了函数需要的信息，这些约定旨在使函数的语法更加可预测。

\noindent 主要的命名约定有:

\begin{itemize}
	\item 为了将X符号与其他符号区分开来，库对外部符号使用混合大小写。按照现有约定，它为变量保留小写字母，为用户宏保留全部大写字母。
	\item 所有Xlib函数都以大写X开头。
	\item 所有函数名和符号的开头都大写。
	\item 所有用户可见的数据结构都以大写X开头。更一般地说，用户可以解引用的任何内容都以大写X开头。
	\item 宏和其他符号不以大写x开头。为了区别于所有用户符号，宏中的每个单词都大写。
	\item 数据结构中的所有元素或变量都是小写的。必要时，复合词用下划线(\_)构成。
	\item 当使用display参数时，它总是在参数列表的第一个。
	\item 所有使用的资源对象都出现在参数列表的开头，紧跟在display参数之后。
	\item 当图形上下文与另一种类型的资源(最常见的是可绘制的资源)一起出现时，图形上下文出现在参数列表中，位于其他资源之后。可抽取资源的排名高于所有其他资源。
	\item 在参数列表中，源参数总是位于目标参数之前。
	\item 在参数列表中，x参数总是位于y参数之前。
	\item 在参数列表中，宽度参数总是位于高度参数之前。
	\item 当x、y、width和height参数一起使用时，x和y参数总是在width和height参数之前。
	\item 当掩码与结构体同时出现时，掩码总是位于参数列表中指向该结构体的指针之前。
\end{itemize}

\subsection{编程注意事项}

\noindent 主要的编程考虑是:

\begin{itemize}
	\item X中的坐标和大小实际上是16位的量。这个决定是为了最小化给定性能级别所需的带宽。坐标通常在接口中声明为int。大于16位的值将被静默截断。尺寸(宽度和高度)被声明为无符号数量。
	\item 键盘是不同制造商工作站之间最大的变量。如果你希望你的程序是可移植的，你应该在这里特别保守。
	\item 许多显示系统的屏幕外内存有限。如果可以的话，应该尽量减少像素图和后备存储的使用。
	\item 用户应该能够控制自己的屏幕空间。因此，您应该编写应用程序来响应窗口管理，而不是假定控制整个屏幕。但是，在顶层窗口内执行的操作取决于应用程序。有关更多信息，请参阅第14章和客户端间通信约定手册。
\end{itemize}

\subsection{字符集和编码}

\noindent 一些Xlib函数引用了特定的字符集和字符编码。以下是最常见的:

\subsubsection{x可移植字符集(X Portable Character Set)}

97个字符的基本集合，假定存在于Xlib支持的所有语言环境中。该字符集包含以下字符:

\begin{lstlisting}
a..z
A..Z
0..9
!"#$\%&'()*+,-./:;<=>?@[\\]^_`{|}~
<space>, <tab>, <newline>
\end{lstlisting}

该字符集是ISO8859-1图形字符集的左/下半部分加上空格、制表符和换行符。它也是7位ASCII的图形字符集加上相同的三个控制字符。这些字符在主机上的实际编码取决于系统。

\subsubsection{主机可移植字符编码}

主机上X可移植字符集的编码。编码本身不是由这个标准定义的，但是在主机上Xlib支持的所有语言环境中，编码必须是相同的。如果一个字符串被称为主机可移植字符编码，那么它只包含来自主机编码的X可移植字符集的字符。

\subsubsection{Latin-1}

由ISO8859-1标准定义的编码字符集。

\subsubsection{Latin可移植字符编码}

使用Latin-1码点加上ASCII控制字符对X可移植字符集进行编码。如果一个字符串被称为Latin Portable Character Encoding，那么它只包含来自X Portable Character Set的字符，而不是Latin-1的所有字符。

\subsubsection{STRING编码}

Latin-1，加上制表符和换行符。

\subsubsection{POSIX可移植文件名字符集}

65个字符的集合，可用于在posix兼容的主机上命名文件，在所有语言环境中都能正确处理。集合为:


\begin{lstlisting}
a..z
A..Z
0..9
._-
\end{lstlisting}

\subsubsection{格式规范}

\noindent Xlib−C语言X接口使用以下约定:

\begin{itemize}

\item 全局符号以这种特殊字体打印。这些可以是函数名、包含文件中定义的符号或结构名。在声明和定义时，函数参数以斜体打印。在后面的解释性文字中，它们通常是用普通字体打印的。
\item 每个函数都是通过一般性讨论来介绍的，以区别于其他函数。函数声明本身紧随其后，并对每个参数进行了具体解释。虽然没有使用ANSI C函数原型语法，但Xlib头文件通常使用ANSI C环境中的函数原型来声明函数。如果需要对函数进行一般性讨论，则在参数之后进行。在适用的情况下，说明的最后一段列出了函数可能生成的Xlib错误码。有关Xlib错误码的完整讨论，请参见第11.8.2节。
\item 为了消除您传递的参数和函数返回给您的参数之间的任何歧义，您传递的所有参数的解释都以单词specify开头，或者在有多个参数的情况下，以单词specify开头。返回给您的所有参数的解释都以单词returns开头，或者在有多个参数的情况下，以单词return开头。您可以传递和返回的所有参数的解释都以单词指定和返回开始。
\item 任何指向用于返回值的结构体的指针都由\_return后缀作为其名称的一部分指定。传递给这些函数的所有其他指针仅用于读取。一些参数使用指向结构体的指针，这些结构体同时用于输入和输出，并使用\_in\_out后缀表示。
\end{itemize}

\section{显示(Display)相关函数}

\noindent 在您的程序可以使用显示器之前，您必须建立到X服务器的连接。一旦建立了连接，就可以使用本章讨论的Xlib宏和函数来返回有关显示的信息。本章讨论以下几点:

\begin{itemize}
	\item 打开(连接到)显示器
	\item 获取有关显示、图像格式或屏幕的信息
	\item 生成一个NoOperation协议请求
	\item 释放客户端创建的数据
	\item 关闭(断开)显示器
	\item 使用X服务器关闭连接操作
	\item 使用带有线程的Xlib
	\item 使用内部连接
\end{itemize}

\subsection{打开显示器}

要打开到控制显示的X服务器的连接，请使用XOpenDisplay。

\begin{lstlisting}[language=C]
	Display* XOpenDisplay(char* display_name);
\end{lstlisting}

\begin{note}
	display\_name: 指定硬件显示名称，该名称确定要使用的显示和通信域。在符合posix的系统上，如果display\_name为NULL，则默认为DISPLAY环境变量的值。
\end{note}

XOpenDisplay函数返回一个Display结构，该结构用作到X服务器的连接，并且包含关于该X服务器的所有信息。XOpenDisplay通过TCP或DECnet通信协议，或通过某些本地进程间通信协议，将应用程序连接到X服务器。如果协议指定为“tcp”、“inet”或“inet6”，或者没有指定协议，主机名是主机名，主机名和显示号之间用一个冒号分隔，XOpenDisplay使用tcp流连接。(如果指定的协议为“inet”，则使用TCP over IPv4。如果指定协议为inet6，则使用TCP over IPv6。否则，实现将决定使用哪个IP版本。)如果没有指定主机名和协议，Xlib将使用它认为最快的传输方式。如果主机名是主机名，用双冒号(::)分隔主机名和显示号，XOpenDisplay使用DECnet进行连接。单个X服务器可以同时支持任何或所有这些传输机制。特定的Xlib实现可以支持更多这样的传输机制。

如果成功，XOpenDisplay返回一个指向Display结构的指针，该结构在<X11/Xlib.h>中定义。如果XOpenDisplay不成功，它返回NULL。在成功调用XOpenDisplay之后，客户机可以使用显示中的所有屏幕。display\_name参数中指定的屏幕编号由DefaultScreen宏(或XDefaultScreen函数)返回。只能通过使用信息宏或函数来访问Display和Screen结构的元素。有关使用宏和函数从Display结构中获取信息的信息，请参见2.2.1节。

\subsection{获取有关显示、图像格式或屏幕的信息}

Xlib库提供了许多有用的宏和相应的函数，它们从Display结构返回数据。这些宏用于C编程，它们对应的函数等价于其他语言绑定。本节讨论:

\begin{itemize}
	\item 显示宏
	\item 图像格式函数和宏
	\item 屏幕信息宏
\end{itemize}

Display结构的所有其他成员(即没有为其定义宏的成员)都是Xlib私有的，不能使用。应用程序绝对不能直接修改或检查Display结构的这些私有成员。下一节中的XDisplayWidth、XDisplayHeight、XDisplayCells、XDisplayPlanes、XDisplayWidthMM和XDisplayHeightMM函数命名不当。这些函数应该命名为Screenwhatever和XScreenwhatever，而不是Displaywhatever或XDisplaywhatever。对于由此造成的混乱，我们深表歉意。

\subsubsection{Display Macros}

应用程序不应该直接修改Display和Screen结构的任何部分。这些成员应该被认为是只读的，尽管它们可能会由于对显示的其他操作而改变。下面列出了C语言的宏，它们对应的用于其他语言绑定的等价函数，以及它们都可以返回的数据。

\begin{lstlisting}[language=C]
unsigned long XAllPlanes(void);
unsigned long XBlackPixel(Display *display, int screen_number);
unsigned long XWhitePixel(Display *display, int screen_number);
int XConnectionNumber(Display *display);
Colormap XDefaultColormap(Display *display, int screen_number);
int XDefaultDepth(Display *display, int screen_number);
int *XListDepths(Display *dsp, int screen_num, int* count_ret);
GC XDefaultGC(Display *display, int screen_number);
Window XDefaultRootWindow(Display *display);
Screen *XDefaultScreenOfDisplay(Display *display);
Screen *XScreenOfDisplay(Display *display, int screen_number);
int XDefaultScreen(Display *display);
Visual *XDefaultVisual(Display *display, int screen_number);
int XDisplayCells(Display *display, int screen_number);
int XDisplayPlanes(Display *display, int screen_number);
char *XDisplayString(Display *display);
long XExtendedMaxRequestSize(Display *display);
long XMaxRequestSize(Display *display);
unsigned long XLastKnownRequestProcessed(Display *display);
unsigned long XNextRequest(Display *display);
int XProtocolVersion(Display *display);
int XProtocolRevision(Display *display);
int XQLength(Display *display);
Window XRootWindow(Display *display, int screen_number);
int XScreenCount(Display *display);
char *XServerVendor(Display *display);
int XVendorRelease(Display *display);
\end{lstlisting}

\subsubsection{图像格式函数和宏}

应用程序需要以服务器要求的格式向X服务器提供数据。为了帮助简化应用程序，转换数据所需的大部分工作都由Xlib提供(参见第8.7和16.8节)。

XPixmapFormatValues结构提供了在连接建立时返回的像素图格式信息的接口。它包含:

\begin{lstlisting}[language=C]
typedef struct {
	int depth;
	int bits_per_pixel;
	int scanline_pad;
} XPixmapFormatValues;
\end{lstlisting}

\noindent 要获取给定显示的像素图格式信息，请使用XListPixmapFormats，其中 count\_return 表示：返回显示所支持的像素图格式的数目。

\begin{lstlisting}[language=C]
XPixmapFormatValues* XListPixmapFormats(
	Display* display,
	int* count_return);
\end{lstlisting}

\noindent XListPixmapFormats函数返回一个XPixmapFormatValues结构数组，这些结构描述了指定显示所支持的Z格式图像的类型。如果可用内存不足，XListPixmapFormats返回NULL。要为XPixmapFormatValues结构释放已分配的存储空间，请使用XFree。

\noindent 下面列出了C语言宏、它们对应的用于其他语言绑定的等价函数，以及它们为指定的服务器和屏幕返回的数据。这些通常被工具包和简单的应用程序使用。

\begin{lstlisting}[language=C]
int XImageByteOrder(Display *display);
\end{lstlisting}

\noindent 两者都为XY格式(位图)的每个扫描线单元或Z格式的每个像素值指定图像所需的字节顺序。宏或函数可以返回LSBFirst或MSBFirst。
\begin{lstlisting}[language=C]
int XBitmapUnit(Display *display);
\end{lstlisting}

\noindent 两者都以位为单位返回位图扫描线的大小。扫描线以该值的倍数计算。
\begin{lstlisting}[language=C]
int XBitmapBitOrder(Display *display);
\end{lstlisting}

\noindent 在每个位图单元中，屏幕上显示的位图中最左边的位要么是该单元中最不重要的位，要么是最重要的位。这个宏或函数可以返回LSBFirst或MSBFirst。
\begin{lstlisting}[language=C]
int XBitmapPad(Display *display);
\end{lstlisting}

\noindent 每个扫描线必须填充为该宏或函数返回的位的倍数。
\begin{lstlisting}[language=C]
int XDisplayHeight(Display *display, int screen_number);
\end{lstlisting}

\noindent 两者都返回一个以像素为单位描述屏幕高度的整数。
\begin{lstlisting}[language=C]
int XDisplayHeightMM(Display *display, int screen_number);
\end{lstlisting}

\noindent 以下都是返回屏幕宽度。
\begin{lstlisting}[language=C]
int XDisplayWidth(Display *display, int screen_number);
int XDisplayWidthMM(Display *display, int screen_number);
\end{lstlisting}

\subsubsection{屏幕信息宏}

\noindent 下面列出了C语言宏，它们对应的用于其他语言绑定的等价函数，以及它们都可以返回的数据。这些宏或函数都有一个指向适当屏幕结构的指针。
\begin{lstlisting}[language=C]
unsigned long XBlackPixelOfScreen(Screen *screen);
unsigned long XWhitePixelOfScreen(Screen *screen);
int XCellsOfScreen(Screen *screen);
Colormap XDefaultColormapOfScreen(Screen *screen);
int XDefaultDepthOfScreen(Screen *screen);
GC XDefaultGCOfScreen(Screen *screen);
Visual *XDefaultVisualOfScreen(Screen *screen);
int XDoesBackingStore(Screen *screen);
Bool XDoesSaveUnders(Screen *screen);
Display *XDisplayOfScreen(Screen *screen);
long XScreenNumberOfScreen(Screen *screen);
long XEventMaskOfScreen(Screen *screen);
int XWidthOfScreen(Screen *screen);
int XHeightOfScreen(Screen *screen);
int XWidthMMOfScreen(Screen *screen);
int XHeightMMOfScreen(Screen *screen);
int XMaxCmapsOfScreen(Screen *screen);
int XMinCmapsOfScreen(Screen *screen);
int XPlanesOfScreen(Screen *screen);
Window XRootWindowOfScreen(Screen *screen);
\end{lstlisting}

\subsection{生成一个 NoOperation 协议请求}

\noindent 要执行NoOperation协议请求，请使用XNoOp。XNoOp函数向X服务器发送一个NoOperation协议请求，从而执行连接。
\begin{lstlisting}[language=C]
XNoOp(Display *display);
\end{lstlisting}

\subsection{释放客户端创建的数据}

\noindent 要释放由Xlib函数创建的内存数据，请使用XFree。XFree函数是一个通用的Xlib例程，用于释放指定的数据。必须使用它来释放由Xlib分配的任何对象，除非为该对象显式指定了替代函数。NULL指针不能传递给这个函数。
\begin{lstlisting}[language=C]
XFree(void *data);
\end{lstlisting}

\subsection{关闭显示器}

\noindent 要关闭显示或断开与X服务器的连接，请使用XCloseDisplay。

\begin{lstlisting}[language=C]
XCloseDisplay(Display *display);
\end{lstlisting}

\noindent XCloseDisplay函数关闭与X服务器的连接，用于display结构中指定的显示，并销毁客户端在此显示上创建的所有窗口，资源id (Window, Font, Pixmap, Colormap, Cursor和GContext)或其他资源，除非客户端的关闭模式被更改(参见XSetCloseDownMode)。因此，不应该再引用这些窗口、资源id和其他资源，否则将生成错误。退出之前，应该显式地调用XCloseDisplay，以便在XCloseDisplay执行最后的XSync操作时报告任何挂起的错误。

\begin{note}
XCloseDisplay会生成BadGC错误。
\end{note}

\noindent Xlib提供了一个函数，允许客户端拥有的资源在客户端连接关闭后继续存在。要更改客户端的关闭模式，请使用XSetCloseDownMode。
\begin{lstlisting}[language=C]
XSetCloseDownMode(Display *display, int close_mode);
\end{lstlisting}

\noindent XSetCloseDownMode函数定义了在连接关闭时客户端资源将发生什么。连接以DestroyAll模式启动。有关close\_mode参数为RetainPermanent或RetainTemporary时客户端资源会发生什么情况的信息，请参见2.6节。

\begin{note}
XSetCloseDownMode会产生一个BadValue错误。
\end{note}

\subsection{使用X服务器连接关闭操作}

\noindent 当X服务器通过显式调用XCloseDisplay或由退出的进程关闭与客户端的连接时，X服务器执行以下自动操作:

\begin{itemize}
	\item 它否定客户端拥有的所有选择(参见XSetSelectionOwner)。
	\item 如果客户端主动抓取了指针或键盘，则执行XUngrabPointer和XUngrabKeyboard操作。
	\item 如果客户端已抓取服务器，则执行XUngrabServer。
	\item 它释放客户端所做的所有被动抓取。
	\item 它将客户端分配的所有资源(包括颜色映射项)标记为永久或临时，这取决于关闭模式是RetainPermanent还是RetainTemporary。然而，这并不能阻止其他客户端应用程序显式地销毁资源(参见XSetCloseDownMode)。
\end{itemize}

\noindent 当关闭模式为DestroyAll时，X服务器将销毁客户端的所有资源，如下所示:

\begin{itemize}
\item 它检查客户端保存集中的每个窗口，以确定它是否是客户端创建的窗口的下级(子窗口)。(保存集是被称为保存集窗口的其他客户端窗口的列表。)如果是这样，X服务器将保存集窗口重新定位到最近的祖先，这样保存集窗口就不会比客户端创建的窗口逊色。重定位使保存集窗口左上角的绝对坐标(相对于根窗口)保持不变。
\item 如果保存集窗口未被映射，它将对保存集窗口执行MapWindow请求。
\item 它会销毁客户端创建的所有窗口。
\item 它对客户端在服务器中创建的每个非窗口资源(例如，Font、Pixmap、Cursor、Colormap和GContext)执行适当的空闲请求。
\item 它释放由客户端应用程序分配的所有颜色和色图项。
\end{itemize}

当最后一个到X服务器的连接关闭时，将进行额外的处理。X服务器会经历一个没有连接和有一些连接的循环。当与X服务器的最后一个连接由于使用DestroyAll的close\_mode关闭连接而关闭时，X服务器执行以下操作:

\begin{itemize}
\item 它会重置它的状态，就好像它刚刚启动一样。X服务器首先销毁来自以RetainPermanent或RetainTemporary模式终止的客户端的所有遗留资源。
\item 它删除除预定义的原子标识符之外的所有标识符。
\item 它删除所有根窗口上的所有属性(参见4.3节)。
\item 它重置所有设备映射和属性(例如，按键、铃声音量和加速度)以及访问控制列表。
\item 它恢复标准的根磁贴和游标。
\item 它恢复默认字体路径。
\item 它将输入焦点恢复到状态PointerRoot。
\end{itemize}

\noindent 但是，如果关闭模式设置为RetainPermanent或RetainTemporary关闭连接，则X服务器不会重置。

\subsection{使用带有线程的Xlib}

\noindent 在支持的系统上，允许多个线程并发地使用Xlib。要初始化对并发线程的支持，请使用XInitThreads。

\begin{lstlisting}[language=C]
Status XInitThreads(void);
\end{lstlisting}

XInitThreads函数初始化Xlib对并发线程的支持。该函数必须是多线程程序调用的第一个Xlib函数，并且必须在进行任何其他Xlib调用之前完成。如果初始化成功，此函数返回非零状态;否则，返回0。在不支持线程的系统上，这个函数总是返回零。

只有当多个线程可能并发地使用Xlib时，才需要调用这个函数。如果对Xlib函数的所有调用都受到某种其他访问机制的保护(例如，工具箱中的互斥锁或通过显式客户机编程)，则不需要Xlib线程初始化。建议单线程程序不要调用这个函数。

要跨多个Xlib调用锁定一个display，请使用XLockDisplay。XLockDisplay函数阻止所有其他线程使用指定的显示。其他试图使用该显示的线程将阻塞，直到该线程解锁该显示。嵌套调用XLockDisplay工作正确;直到XUnlockDisplay被调用的次数与XLockDisplay相同，显示才会真正被解锁。除非使用XInitThreads为线程成功初始化Xlib，否则此函数不起作用。

XUnlockDisplay函数允许其他线程再次使用指定的显示。任何在显示上被阻塞的线程都被允许继续。嵌套锁工作正确;如果一个线程多次调用XLockDisplay，那么在实际解锁显示之前，必须调用相同次数的XUnlockDisplay。除非使用XInitThreads为线程成功初始化Xlib，否则此函数不起作用。

\begin{lstlisting}[language=C]
XLockDisplay(Display *display);
XUnlockDisplay(Display *display);
\end{lstlisting}

\subsection{使用内部连接}

除了连接到X服务器之外，Xlib实现可能还需要连接到其他类型的服务器(例如，第13章中描述的输入法服务器)。使用多个显示器或将显示器与其他输入结合使用的工具包和客户端需要获得这些额外的连接以正确地阻塞，直到输入可用，并且需要在输入可用时处理该输入。在Xlib事件函数中使用单个显示和块作为输入的简单客户机不需要使用这些功能。

\noindent 要跟踪显示器的内部连接，请使用XAddConnectionWatch。

\begin{lstlisting}[language=C]
typedef void (*XConnectionWatchProc)(Display *display, XPointer client_data, int fd, Bool opening, XPointer *watch_data);
Status XAddConnectionWatch(Display *display, XConnectionWatchProc procedure, XPointer client_data);
\end{lstlisting}

XAddConnectionWatch函数注册一个过程，在Xlib每次打开或关闭指定显示的内部连接时调用该过程。传递给过程的是显示、指定的client\_data、连接的文件描述符、指示连接是打开还是关闭的布尔值，以及指向私有监视数据位置的指针。如果open为True，过程可以在watch\_data所指向的位置存储一个指向私有数据的指针;当稍后对同一连接调用该过程并且open为False时，watch\_data所指向的位置将保存相同的私有数据指针。

这个函数可以在打开显示后的任何时间调用。如果内部连接已经存在，在XAddConnectionWatch返回之前，将立即为每个内部连接调用已注册的过程。如果过程成功注册，XAddConnectionWatch返回一个非零状态;否则，返回0。

注册的过程不应该调用任何Xlib函数。如果过程直接或间接导致内部连接或监视过程的状态发生变化，则不定义结果。如果已经为线程初始化了Xlib，则调用过程时会锁定显示，并且过程对锁定显示的任何Xlib函数的调用结果都没有定义，除非执行线程使用XLockDisplay从外部锁定了显示。

\noindent 要停止跟踪显示的内部连接，请使用XRemoveConnectionWatch。XRemoveConnectionWatch函数删除先前注册的连接监视过程。client\_data必须与过程最初注册时使用的client\_data匹配。
\begin{lstlisting}[language=C]
Status XRemoveConnectionWatch(Display *display, XConnectionWatchProc procedure, XPointer client_data);
\end{lstlisting}

\noindent 要处理内部连接上的输入，请使用XProcessInternalConnection。
\begin{lstlisting}[language=C]
void XProcessInternalConnection(Display *display, int fd);
\end{lstlisting}

\noindent XProcessInternalConnection函数处理内部连接上可用的输入。只有在操作系统功能(例如select或poll)指示输入可用后，才应该为内部连接调用此函数;否则，效果没有定义。

\noindent 要获取显示器的所有当前内部连接，请使用XInternalConnectionNumbers。
\begin{lstlisting}[language=C]
Status XInternalConnectionNumbers(Display *display, int ** fd, int * count_return);
\end{lstlisting}

\noindent XInternalConnectionNumbers函数返回当前为指定显示打开的所有内部连接的文件描述符列表。当不再需要分配的列表时，使用XFree释放它。如果列表被成功分配，这个函数返回一个非零状态;否则，返回0。

\section{窗口(Window)相关函数}

\subsection{视觉类型}

在某些显示硬件上，可能以多种方式处理色彩资源。例如，您可能能够处理12位深度的屏幕，其中像素到颜色(伪色)的任意映射，或者24位深度的屏幕，其中8位像素分别用于红色，绿色和蓝色。这些处理屏幕视觉方面的不同方式被称为视觉效果。对于显示器的每个屏幕，可能有一个在屏幕不同深度处支持的有效可视类型列表。因为默认窗口和可视类型是为每个屏幕定义的，所以大多数简单的应用程序不需要处理这种复杂性。Xlib提供了返回默认根窗口、默认根窗口的默认深度和默认可视类型的宏和函数(参见第2.2.1和16.7节)。

Xlib使用不透明的Visual结构，其中包含有关可能的颜色映射的信息。可视化实用程序函数(参见第16.7节)使用XVisualInfo结构将这些信息返回给应用程序。这个结构体的成员是class、red\_mask、green\_mask、blue\_mask、bits\_per\_rgb和colormap\_size。类成员指定屏幕可能的可视类之一，可以是StaticGray、StaticColor、TrueColor、GrayScale、PseudoColor或DirectColor。

以下概念可能有助于更清楚地解释视觉类型。屏幕可以是彩色的或灰度的，可以有一个可写的或只读的颜色映射，也可以有一个颜色映射，它的索引被分解成单独的RGB块，前提是它不在灰度屏幕上。这导致了下图:

\begin{center}
	\tablefirsthead{
		\hline
		\multicolumn{1}{|l}{} &
		\multicolumn{2}{|c}{Color} &
		\multicolumn{2}{|c|}{Gray-Scale} \\
		\multicolumn{1}{|l}{} &
		\multicolumn{1}{|l}{R/O} &
		\multicolumn{1}{l|}{R/W} &
		\multicolumn{1}{l}{R/O} &
		\multicolumn{1}{l|}{R/W} \\
		\hline
	}
	\begin{supertabular}{|l|l|l|l|l|}
		Undecomposed & Static & Pseudo & Static & Gray\\
		Colormap & Color & Color & Gray & Scale\\
		Decomposed & True & Direct & & \\
		Colormap & Color & Color & & \\
		\hline
		
	\end{supertabular}
\end{center}

从概念上讲，当从显存中读取每个像素以便在屏幕上显示时，它通过索引到颜色映射来经历查找阶段。颜色映射可以在某些硬件上任意操作，在其他硬件上以有限的方式操作，而在其他硬件上则完全不能操作。视觉类型通过以下方式影响颜色图和RGB值:

\begin{itemize}
	\item 对于PseudoColor，像素值索引颜色图以生成独立的RGB值，并且RGB值可以动态更改。
	\item 灰度的处理方式与PseudoColor相同，只是驱动屏幕的原色是未定义的。因此，客户端应该始终在颜色映射中为红色、绿色和蓝色存储相同的值。
	\item 对于DirectColor，像素值被分解为单独的RGB子字段，每个子字段分别索引对应值的颜色图。RGB值可以动态更改。
	\item TrueColor的处理方式与DirectColor相同，除了颜色映射具有预定义的只读RGB值。这些RGB值依赖于服务器，但在每个主服务器中提供线性或近似线性的斜坡。
	\item StaticColor的处理方式与PseudoColor相同，只是颜色映射具有预定义的、只读的、依赖于服务器的RGB值。
	\item 处理StaticGray的方式与处理StaticColor的方式相同，只是RGB值对于任何单个像素值都是相等的，因此会产生灰色阴影。具有两项颜色映射的StaticGray可以被认为是单色的。
\end{itemize}

red\_mask, green\_mask和blue\_mask成员仅为DirectColor和TrueColor定义。每个都有一组连续的位，没有交集。bits\_per\_rgb成员指定以2为基数的红、绿、蓝不同颜色值的数量。实际的RGB值是无符号的16位数字。colormap\_size成员定义了新创建的colormap中可用的colormap条目的数量。对于DirectColor和TrueColor，这是单个像素子字段的大小。

\noindent 使用XVisualIDFromVisual从visual中获取可视ID。
\begin{lstlisting}[language=C]
VisualID XVisualIDFromVisual(Visual *visual);
\end{lstlisting}

\noindent XVisualIDFromVisual函数的作用是:返回指定可视类型的可视ID。

\subsection{窗口属性}

所有的InputOutput窗口都有一个边框宽度为零或更多像素的边框，一个可选的背景，一个事件抑制掩码(用于抑制子事件的传播)，以及一个属性列表。窗口边框和背景可以是纯色或图案，称为tile。除了根目录之外的所有窗口都有一个父窗口，并被它们的父窗口剪切。如果一个窗口被堆叠在另一个窗口的顶部，为了输入的目的，它会遮蔽其他窗口。如果一个窗口有背景(几乎所有的窗口都有)，为了输出的目的，它会掩盖其他窗口。输出到模糊区域的尝试不做任何事情，并且不会为模糊区域生成输入事件(例如，鼠标运动)。

\noindent Windows也有相关的属性列表

\noindent InputOutput和InputOnly窗口都有以下共同属性，这是InputOnly窗口的唯一属性:

\begin{itemize}
	\item win-gravity
	\item event-mask
	\item do-not-propagate-mask
	\item override-redirect
	\item cursor
\end{itemize}

如果为InputOnly窗口指定任何其他属性，则会导致BadMatch错误。

InputOnly窗口用于在不需要InputOutput窗口的情况下控制输入事件。InputOnly窗口是不可见的;只能用于控制诸如游标、输入事件生成和抓取之类的东西;并且不能用于任何图形请求。注意，InputOnly窗口不能将InputOutput窗口作为下级。

窗口具有可编程宽度和图案的边框以及背景图案或平铺。像素值可用于纯色。背景和边界像素图可以在创建窗口后立即销毁，如果没有进一步明确引用它们。模式可以是相对于父模式的，也可以是绝对模式的。如果ParentRelative，则使用父母的背景。

当第一次创建窗口时，它们在屏幕上不可见(不映射)。对屏幕上不可见且没有后备存储的窗口的任何输出都将被丢弃。应用程序可能希望在将窗口映射到屏幕之前创建一个窗口。当一个窗口最终映射到屏幕时(使用XMapWindow)，如果没有维护后备存储，X服务器将为该窗口生成一个Expose事件。

窗口管理器可以覆盖您对顶级窗口的大小、边框宽度和位置的选择。您的程序必须准备好使用顶部窗口的实际大小和位置。除非直接响应人工命令，否则客户端应用程序不能自行调整大小。相反，您的程序应该使用给定的空间，或者如果空间太小，无法进行任何有用的工作，您的程序可能会要求用户调整窗口大小。对于窗口管理器来说，顶级窗口的边界被认为是公平的。

要设置窗口的属性，请在后续调用XCreateWindow和xchangewindowwatattributes时设置xsetwindowatattributes结构的适当成员和相应值位掩码中的OR，或者使用其他设置适当属性的方便函数之一。值掩码位和xsetwindowatattributes结构的符号是:

\begin{lstlisting}[language=C]
/* Window attribute value mask bits */
#define    CWBackPixmap                    (1L<<0)
#define    CWBackPixel                     (1L<<1)
#define    CWBorderPixmap                  (1L<<2)
#define    CWBorderPixel                   (1L<<3)
#define    CWBitGravity                    (1L<<4)
#define    CWWinGravity                    (1L<<5)
#define    CWBackingStore                  (1L<<6)
#define    CWBackingPlanes                 (1L<<7)
#define    CWBackingPixel                  (1L<<8)
#define    CWOverrideRedirect              (1L<<9)
#define    CWSaveUnder                     (1L<<10)
#define    CWEventMask                     (1L<<11)
#define    CWDontPropagate                 (1L<<12)
#define    CWColormap                      (1L<<13)
#define    CWCursor                        (1L<<14)


/* Values */
typedef struct {
	/* background, None, or ParentRelative */
	Pixmap background_pixmap;  
	
	/* background pixel */   
	unsigned long background_pixel;
	
	/* border of the window or CopyFromParent */     
	Pixmap border_pixmap;   
	
	/* border pixel value */       
	unsigned long border_pixel; 
	
	/* one of bit gravity values */    
	int bit_gravity;  
	
	/* one of the window gravity values */   
	int win_gravity;
	
	/* NotUseful, WhenMapped, Always */     
	int backing_store;     
	
	/* planes to be preserved if possible */
	unsigned long backing_planes; 
	
	/* value to use in restoring planes */    
	unsigned long backing_pixel;  
	
	/* should bits under be saved? (popups) */   
	Bool save_under;     
	
	/* set of events that should be saved */
	long event_mask;     
	
	/* set of events that should not propagate */
	long do_not_propagate_mask;  
	
	/* boolean value for override_redirect */   
	Bool override_redirect;   
	
	/* color map to be associated with window */  
	Colormap colormap;   
	
	 /* cursor to be displayed (or None) */  
	Cursor cursor;         
} XSetWindowAttributes;
\end{lstlisting}

\noindent 下面列出了每个窗口属性的默认值，并指出该属性是否适用于InputOutput和InputOnly窗口:

\begin{center}
	\tablefirsthead{
		\hline
		\multicolumn{1}{|l}{Attribute} &
		\multicolumn{1}{|l}{Default} &
		\multicolumn{1}{l|}{InputOutput} &
		\multicolumn{1}{l|}{InputOnly} \\
		\hline
	}
	\begin{supertabular}{|l|l|l|l|}
		background-pixmap & None & Yes & No \\
		background-pixel & Undefined & Yes & No \\
		border-pixmap & CopyFromParent & Yes & No \\
		border-pixel & Undefined & Yes & No \\
		bit-gravity & ForgetGravity & Yes & No \\
		win-gravity & NorthWestGravity & Yes & Yes \\
		backing-store & NotUseful & Yes & No \\
		backing-planes & All ones & Yes & No \\
		backing-pixel & zero & Yes & No \\
		save-under & False & Yes & No \\
		event-mask & empty set & Yes & Yes \\
		do-not-propagate-mask & empty set & Yes & Yes \\
		override-redirect & False & Yes & Yes \\
		colormap & CopyFromParent & Yes & No \\
		cursor & None & Yes & Yes \\
		\hline
	\end{supertabular}
\end{center}

\subsection{背景属性}

只有输入输出窗口可以有背景。您可以使用像素或像素图来设置InputOutput窗口的背景。

窗口的background-pixmap属性指定用于窗口背景的像素图。这个像素图可以是任何大小，尽管某些大小可能比其他大小快。窗口的background-pixel属性指定用于以单一颜色绘制窗口背景的像素值。

您可以将背景像素图设置为像素图、None(默认)或ParentRelative。您可以将窗口的背景像素设置为任何像素值(无默认值)。如果指定背景像素，它将覆盖默认背景像素或您可能在背景像素中设置的任何值。使用未定义大小的像素图填充背景像素作为背景。背景像素未进行距离检查;它只是被截断到适当的位数。

如果设置背景像素图，它将覆盖默认值。背景像素图和窗口必须具有相同的深度，否则会导致BadMatch错误。如果将background-pixmap设置为None，则窗口没有定义背景。如果你将背景像素图设置为ParentRelative:

\begin{itemize}
	\item 使用父窗口的背景像素图。但是，子窗口必须具有与其父窗口相同的深度，否则会导致BadMatch错误。
	\item 如果父窗口的背景像素图为None，则该窗口的背景像素图也为None。
	\item 不会生成父窗口背景像素图的副本。每次需要子窗口的背景像素图时，都会检查父窗口的背景像素图。
	\item 背景平铺原点总是与父窗口的背景平铺原点对齐。如果背景像素图不是ParentRelative，则背景贴图的原点是子窗口的原点。
\end{itemize}

设置新背景，无论是通过设置背景像素还是背景像素，都会覆盖之前的任何背景。如果没有对background-pixmap进行进一步的显式引用，则可以立即释放它(X服务器将保留一个副本以便在需要时使用)。如果稍后将其绘制到用于背景的像素图中，则会发生什么情况是未定义的，因为X实现可以自由地复制该像素图或使用相同的像素图。

当窗口的区域没有有效的内容可用，并且区域是可见的或者服务器正在维护后备存储时，服务器会自动将该区域与窗口的背景平铺，除非该窗口的背景为None。如果背景为None，则只要内容来自该窗口的父窗口或父窗口的下级窗口，则与该窗口深度相同的其他窗口的先前屏幕内容将被保留在原地。否则，暴露区域的初始内容是未定义的。然后为区域生成暴露事件，即使背景像素图为None。

\subsection{边框属性}

只有InputOutput窗口可以有边框。您可以使用像素或像素图来设置InputOutput窗口的边框。

窗口的border-pixmap属性指定用于窗口边框的像素图。窗口的border-pixel属性指定了一个未定义大小的像素图，其中填充了用于窗口边界的像素。背景像素未进行距离检查;它只是被截断到适当的位数。边框贴图的原点总是与背景贴图的原点相同。

您还可以将border-pixmap设置为任意大小的像素图(有些可能比其他像素图更快)或CopyFromParent(默认)。您可以将边框像素设置为任何像素值(无默认值)。

如果设置边框像素图，它将覆盖默认值。边界像素图和窗口必须具有相同的深度，否则会导致BadMatch错误。如果将border-pixmap设置为CopyFromParent，则复制父窗口的border-pixmap。后续对父窗口边框属性的更改不会影响子窗口。但是，子窗口必须具有与父窗口相同的深度，否则会导致BadMatch错误。

如果没有对边界像素图进行进一步的显式引用，则可以立即释放它。如果稍后绘制用于边界的像素图，则会发生什么情况是未定义的，因为X实现可以自由地复制像素图或使用相同的像素图。如果指定了边框像素，它将覆盖默认边框像素或您可能在边框像素中设置的任何值。窗口边框中的所有像素都将被设置为边框像素。设置新边框(无论是通过设置border-pixel还是通过设置border-pixmap)都会覆盖以前的任何边框。

窗口的输出总是被裁剪到窗口的内部。因此，图形操作永远不会影响窗口边框。

\subsection{Gravity属性}

窗口的位重力定义了在调整InputOutput窗口大小时应该保留窗口的哪个区域。位重力属性的默认值是ForgetGravity。窗口的窗口重力允许您定义在其父窗口大小被调整时，InputOutput或InputOnly窗口应该如何重新定位。win-gravity属性的默认值是NorthWestGravity。

如果没有更改窗口的内部宽度或高度，并且如果移动窗口或更改其边框，则窗口的内容不会丢失，而是随着窗口移动。更改窗口的内部宽度或高度会导致其内容被移动或丢失(取决于窗口的位重力)，并导致子窗口被重新配置(取决于它们的win-gravity)。对于宽度和高度的变化，定义(x, y)对:
